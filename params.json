{"tagline":"A build tool designed to make a single, browser compatable, file out of your front end project","google":"","name":"Bigfile","body":"### welcome\r\nThis project is an experiment born out of frustration trying to write and consume modular code. JS is a language which offers no support for modules. At first this seems like a weakness, however I have come to see this as a strength. In filling the void we have seen the flexible common JS (CJS) format take hold on the server and AMD on the web. And now finally language designers are looking to implement a [native system](http://wiki.ecmascript.org/doku.php?id=harmony:modules). However, the only thing we can really hope to gain from it now is syntactic abstraction. i.e. network latency will continue to be a problem.  \r\nOne solution to dealing with network latency is to compile modules together into big files. You might be able to take a guess at what this project does considering its name then. Another, and better solution, is to continue to load files individually but cache them on the client since users won't have to reload code they already have as often.  \r\nHowever, in any case their is merit to having a build step in between code you author and code you publish. This project aims to provide those merits in a flexible framework. BigFile allows you to pull together divers code bases. That diversity might come through differing module formats or languages.  \r\nThink its a bad idea to author in more than one language? You only need to venture as far as HTML and CSS to enjoy the benefits BigFile provides over simple concatenation.\r\n\r\n### State of modules\r\nTheir are only really two module formats in popular use AMD and the node flavour of CJS. AMD is better for the web while CJS is simpler and so is more popular on the server. The differences are actually fairly inconsequential though since in production projects are compiled anyway. By compiled I mean concatenated in to just a few big files. Sometimes async loading is desirable in which case AMD is easier but mostly because it has better tooling available for the job. CJS converts easily to AMD in any case. Your choose of module format is largely irrelevant when it comes to managing JS. However, the web is more than just JS. To make anything for the web you probably want to make use of HTML and CSS at the very least (I say probably because you could in fact only use JS, apart from the initial bit of HTML needed to load the JS). There are many many more languages which compile to be used on the web now too. In my opinion the interaction between languages is weak. And its due to a poor build time tooling.\r\n\r\n### Lament\r\nA module by definition is a unit. Its one conceptual thing. There boundary is usually defined by a job to be done. Consuming a module should be a matter of grabbing a hold of it and telling it to do its thing. That means if a module requires you to load some JS then some CSS and HTML it is not a module. Its hard to think of it as one thing since to grab it you grab its contents. This feels weird looks weird and is error prone. \r\n\r\n### General qualms\r\n1. Access via magic\r\nnpm uses a central repository to hold all modules and uses names as ids to grab them. So the person reading your code must know which module system you are using in order to work out what code you are depending on. Then they must look into the meta data file to see which version. This is a pain for users and adds complexity to the tooling. The only thing needed to grab a module should be its location. i.e. a path or URL. AMD is the only system I know of which embraces this idea.\r\n2. [Namesquating](https://npmjs.org/~flashsoft) \r\nIt defeats the few merits of using magic names when producers can't pick the name they want.\r\n\r\n### Specific qualms\r\nMany tools have been designed to address issues around front end code reuse and modularisation. This is not a complete list but as much as I can remember of the top of my head. It is through an unfortunate process of elimination that I ended up writing this tool. Hopefully you agree it has potential.\r\n\r\n* AMD  \r\nRequires complex tooling to do anything above plain JS loading. This opinion is based on current implementations not on principle. I used AMD for everything until one day I got fed up by its complexity.\r\n* [Browserify](https://github.com/substack/node-browserify)  \r\nInflexible; only works with cjs formated JS/coffeescript\r\n* [Webmake](https://github.com/medikoo/modules-webmake)  \r\nAs above\r\n* [browserbuild](https://github.com/LearnBoost/browserbuild)  \r\nAs above\r\n* [frequire](https://github.com/stagas/frequire)  \r\nI wasn't aware of this project till after I wrote this one. Its designed to support node modules and components but seems to depend on a lot of per project config to do it (a problem I had with Glue). It does a lot but is about as flexible as concrete.\r\n* [Glue](http://mixu.net/gluejs/)  \r\nVery flexible but its intended primarily for small packages. It struggles with external dependencies (at least I couldn't get it working properly). My work is heavily inspired by Glue.\r\n* [Folio](https://github.com/logicalparadox/folio)  \r\nActs as a build system framework. Functionality comes entirely from middleware plugins. Its architecture is similar to [connect](https://npmjs.org/package/connect) then. I think this is brilliant and will likely adapt this project to simply be a plugin for folio in the future. Folio comes bundled with a lot of middleware bringing it to a similar level to Glue in terms of functionality.\r\n* [component/component](https://component.jit.su)  \r\nI dislike all the meta data files. They feel unnecessary and error prone but a promising ecosystem is evolving. It looks like it might offer a nice transition to the upcoming native HTML components.\r\n* [Yeoman](http://yeoman.io/)  \r\nHe'll make you organise you project by language which to me is like organizing a supermarket by color.\r\n* [lineman](https://github.com/testdouble/lineman)  \r\nAs above\r\n* [Geartrain](https://github.com/airportyh/geartrain)  \r\nYou have to write your code a certain way to use it\r\n* [AssetGraph](https://github.com/One-com/assetgraph)  \r\nThis might be good but I don't understand it. I didn't give it much time because I got the impression it was designed for making websites and wouldn't be good for apps.\r\n\r\nThe main issue I have with these package managers is the buy in they require with the exception of Glue. They leave little room to solve problems when you run in to them.\r\n\r\n### A better way\r\nThe first key decision I think we need to make is to use URL's to require modules. URL's have proven themselves robust and are widely understood. There are two obvious rebuttals people might have with this idea. Code size due to all the long strings. Readability, due to all the extra info in URL's you don't need to know. I'll start with code size since its the easiest to answer. Build it out. `require('http://code.jquery.com/jquery.js')` could become `require(0)` in production code very easily or for that matter `r(0)`. Meanwhile the readability thing is something to solve within you code editor, through a plugin maybe. Your code editor should be able to present this to you `require(dom/manipulator)` in place of the URL. It will do this because in your list of familiar modules this is how you categorized jquery. I think their is a lot of cool things you can do once you start personalizing things from the code editor side but for the sake of this discussion I think all I need to say is that it would be fairly easy to make things as readable as they currently are with magic module names of today.\r\n\r\n### Legacy support\r\nThanks to the powers of the flexible dependency resolution tool [SourceGraph](https://github.com/jkroso/SourceGraph) it is fairly easy to pull together code from other systems like npm or component/component. BigFile then offers a feature taken from Glue called handlers which allows to hook into the files of your choosing through Regex and transform their content via a function. Out of the box BigFile allows you to build projects containing JS, CSS, and handlebars templates which can be drawn from proper paths and/or the magic paths of node and component/component. ","note":"Don't delete this file! It's used internally to help with page regeneration."}