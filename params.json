{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A build tool designed to make a single, browser compatable, file out of your front end project","body":"### welcome\r\nThis project is an experiment born out of frustration trying to write and consume modular code. JS is a language which offers no support for modules. At first this seems like a weakness since all other mainstream languages do. However I have come to see this as a strength and an opportunity. I think its possible to implement a first class module system for the web. Now if you know your JS you know a native module system is on its way. However I think it is unlikely to amount to much more than syntactic sugar since I see no plans to deal with network latency. BigFile will easily allow you to author in the new format and integrate those modules with the rest of your project.\r\n\r\n### State of modules\r\nTheir are only really two module formats in popular use AMD and the node flavor of CJS. AMD is better for the web while CJS is simpler and so is more popular on the server. The differences are actually fairly inconsequential though since in production projects are compiled anyway. By compiled I mean concatenated in to just a few big files. Sometimes async loading is desirable in which case AMD is easier but mostly because it has better tooling available for the job. CJS converts easily to AMD in any case. Your choose of module format is largely irrelevant when it comes to managing JS. However, the web is more than just JS. To make anything for the web you probably want to make use of HTML and CSS at the very least (I say probably because you could in fact only use JS, apart from the initial bit of HTML needed to load the JS). There are many many more languages which compile to be used on the web now too. In my opinion the interaction between languages is weak. And its due to a poor build time tooling.\r\n\r\n### Lament\r\nA module by definition is a unit. Its one conceptual thing. There boundary is usually defined by a job to be done. Consuming a module should be a matter of grabbing a hold of it and telling it to do its thing. That means if a module requires you to load some JS then some CSS and HTML it is not a module. Its hard to think of it as one thing since to grab it you grab its contents. This feels weird looks weird and is error prone. \r\n\r\n### General qualms\r\n1. Access via magic\r\nnpm uses a central repository to hold all modules and uses names as ids to grab them. So the person reading your code must know which module system you are using in order to work out what code you are depending on. Then they must look into the meta data file to see which version. This is a pain for users and adds complexity to the tooling. The only thing needed to grab a module should be its location. i.e. a path or URL. AMD is the only system I know of which embraces this idea.\r\n2. [Namesquating](https://npmjs.org/~flashsoft) \r\nIt defeats the few merits of using magic names when producers can't pick the name they want.\r\n\r\n### Specific qualms\r\nMany tools have been designed to address issues around front end code reuse and modularisation. This is not a complete list but as much as I can remember of the top of my head. It is through an unfortunate process of elimination that I ended up writing this tool. Hopefully you agree it has potential.\r\n\r\n* AMD  \r\nRequires complex tooling to do anything above plain JS loading. This opinion is based on current implementations not on principle. I used AMD for everything until one day I got fed up by its complexity.\r\n* [Browserify](https://github.com/substack/node-browserify)  \r\nInflexible; only works with cjs formated JS/coffeescript\r\n* [Webmake](https://github.com/medikoo/modules-webmake)  \r\nAs above\r\n* [browserbuild](https://github.com/LearnBoost/browserbuild)  \r\nAs above\r\n* [frequire](https://github.com/stagas/frequire)  \r\nI wasn't aware of this project before I wrote this\r\n* [Glue](http://mixu.net/gluejs/)  \r\nVery flexible but its intended primarily for small packages. It struggles with external dependencies (at least I couldn't get it working properly). My work is heavily inspired by Glue.\r\n* [component/component](https://component.jit.su)  \r\nI dislike all the meta data files. They feel unnecessary and error prone but a promising ecosystem is evolving. It looks like it might offer a nice transition to the upcoming native HTML components.\r\n* [Yeoman](http://yeoman.io/)  \r\nHe'll make you organise you project by language which to me is like organizing a supermarket by color.\r\n* [lineman](https://github.com/testdouble/lineman)  \r\nAs above\r\n* [Geartrain](https://github.com/airportyh/geartrain)  \r\nYou have to write your code a certain way to use it\r\n* [AssetGraph](https://github.com/One-com/assetgraph)  \r\nThis might be good but I don't understand it. I didn't give it much time because I got the impression it was designed for making websites and wouldn't be good for apps.\r\n\r\nThe main issue I have with these package managers is the buy in they require with the exception of Glue. They leave little room to solve problems when you run in to them.\r\n\r\n### A better way\r\nThe first key decision I think we need to make is to use URL's to require modules. URL's have proven themselves robust and are widely understood. There are two obvious rebuttals people might have with this idea. Code size due to all the long strings. Readability, due to all the extra info in URL's you don't need to know. I'll start with code size since its the easiest to answer. Build it out. `require('http://code.jquery.com/jquery.js')` could become `require(0)` in production code very easily or for that matter `r(0)`. Meanwhile the readability thing is something to solve within you code editor, through a plugin maybe. Your code editor should be able to present this to you `require(dom/manipulator)` in place of the URL. It will do this because in your list of familiar modules this is how you categorized jquery. I think their is a lot of cool things you can do once you start personalizing things from the code editor side but for the sake of this discussion I think all I need to say is that it would be fairly easy to make things as readable as they currently are with magic module names of today.\r\n\r\n### Legacy support\r\nThanks to the powers of the flexible dependency resolution tool [SourceGraph](https://github.com/jkroso/SourceGraph) it is fairly easy to pull together code from other systems like npm or component/component. BigFile then offers a feature taken from Glue called handlers which allows to hook into the files of your choosing through Regexp and transform their content via a function. Out of the box BigFile allows you to build projects containing JS, CSS, and handlebars templates which can be drawn from proper paths and/or the magic paths of node and component/component. ","name":"Bigfile","google":""}