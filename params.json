{"body":"### welcome\r\nThis project is an experiment born out of frustration trying to write and consume modular code. JS is a language which offers no support for modules. At first this seems like a weakness since all other mainstream languages do. However I have come to see this as a strength and an opportunity. I think its possible to implement a first class module system for the web. Now if you know your JS you know a native module system is on its way. However I think they are unlikely to amount to much more than syntactic sugar since I see no plans to deal with network latency. BigFile will easily allow you to author in the new format and integrate those modules with the rest of your project.\r\n\r\n### State of modules\r\nTheir are only really two module formats in popular use AMD and the node flavour of CJS. AMD is better for the web while CJS is simpler and so is more popular on the server. The differences are actually fairly inconsequential though since in production projects are compiled anyway. By compiled I mean concatenated in to just a few big files. Sometimes async loading is desirable in which case AMD is easier but mostly because it has better tooling available for the job. CJS converts easily to AMD in any case. Your choose of module format is largely irrelevent when it comes to managing JS. However, the web is more than just JS. To make anything for the web you probably want to make use of HTML and CSS at the very least (I say probably because you could in fact only use JS, apart from the initial bit of HTML needed to load the JS). There are many many more languages which compile to be used on the web now too. In my opinion the interaction between languages is weak. And its due to a poor build time tooling.\r\n\r\n### Lament\r\nA module by definition is a unit. Its one conceptual thing. There boundary is usaully defined by a job to be done. Consuming a module should be a matter of grabbing a hold of it and telling it to do its thing. That means if a module requires you to load some JS then some CSS and HTML it is not a module. Its hard to think of it as one thing since to grab it you grab its contents. This feels weird looks weird and is error prone. \r\n\r\n### General quams\r\n1. Access via magic\r\nnpm uses a central repository to hold all modules and uses names as ids to grab them. So the person reading your code must know which module system you are using in order to work out what code you are depending on. Then they must look into the meta data file to see which version. This is a pain for users and adds complexity to the tooling. The only thing needed to grab a module should be its location. i.e. a path or url. AMD is the only system I know of which embraces this idea.\r\n2. [Namesquating](https://npmjs.org/~flashsoft) \r\nIt defeats the few merits of using magic names when producers can't pick the name they want.\r\n\r\n### Specific quams\r\nMany tools have been designed to address issues around front end code reuse and modularisation. This is not a complete list but as much as I can remember of the top of my head. It is through an unfortunate process of elimination that I ended up writing this tool. Hopefully you agree it has potential.\r\n\r\n* AMD  \r\nRequires complex tooling to do anything above plain JS loading. This opinion is based on current implementations not on principle. I used AMD for everything until one day I got fed up by its complexity.\r\n* [Browserify](https://github.com/substack/node-browserify)  \r\nInflexible; only works with cjs formated JS/coffeescript\r\n* [Webmake](https://github.com/medikoo/modules-webmake)  \r\nAs above\r\n* [Glue](http://mixu.net/gluejs/)  \r\nVery flexible but its intended primarily for small packages. It struggles with external dependencies (at least I couldn't get it working properly). My work is heavily inspired by Glue.\r\n* [component/component](https://component.jit.su)  \r\nI dislike all the meta data files. They feel uneccesarry and error prone but a promising ecosystem is evolving. It looks like it might offer a nice transition to the upcoming native HTML components.\r\n* [Yeoman](http://yeoman.io/)  \r\nHe'll make you organise you project by language which to me is like organising a supermarket by color.\r\n* [lineman](https://github.com/testdouble/lineman)  \r\nAs above\r\n* [Geartrain](https://github.com/airportyh/geartrain)  \r\nYou have to write your code a certain way to use it\r\n* [AssetGraph](https://github.com/One-com/assetgraph)  \r\nThis might be good but I don't understand it. I didn't give it much time because I got the impression it was designed for making websites and wouldn't be good for apps.\r\n\r\nThe main issue I have with these package managers is the buy in they require with the exception of Glue. They leave little room to solve problems when you run in to them.\r\n\r\n\r\n","google":"","tagline":"A build tool designed to make a single, browser compatable, file out of your front end project","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Bigfile"}